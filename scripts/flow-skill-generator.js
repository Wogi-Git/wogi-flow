#!/usr/bin/env node

/**
 * Skill Generator for Wogi Flow
 * Fetches documentation via Context7 MCP and generates skill files
 */

const fs = require('fs');
const path = require('path');

// ============================================
// CONFIGURATION
// ============================================

const SKILL_TOPICS = {
  patterns: 'best practices common patterns',
  antiPatterns: 'common mistakes anti-patterns pitfalls',
  conventions: 'coding conventions style guide',
  gettingStarted: 'getting started setup installation'
};

// Technology-specific keywords for better doc extraction
const TECH_KEYWORDS = {
  nextjs: ['app router', 'server components', 'server actions', 'middleware', 'api routes'],
  react: ['hooks', 'context', 'suspense', 'concurrent', 'server components'],
  tailwind: ['utility classes', 'responsive', 'dark mode', 'configuration'],
  prisma: ['schema', 'migrations', 'queries', 'relations', 'transactions'],
  nestjs: ['modules', 'controllers', 'providers', 'guards', 'interceptors'],
  fastapi: ['routes', 'dependencies', 'pydantic', 'async', 'middleware'],
  vue: ['composition api', 'reactivity', 'components', 'directives'],
  svelte: ['stores', 'actions', 'transitions', 'ssr']
};

// ============================================
// CONTEXT7 MCP INTEGRATION
// ============================================

/**
 * This function is designed to work with Claude Code's MCP infrastructure.
 * When run directly, it outputs instructions for manual Context7 fetching.
 * When used via Claude, Claude should call Context7 MCP tools directly.
 */
async function fetchDocsViaContext7(technology) {
  // When run via Claude, return null to signal Claude should use MCP
  if (process.env.WOGI_MCP_MODE === 'true') {
    return null; // Claude will use resolve-library-id + get-library-docs
  }

  // When run directly, we can't call MCP - output instructions
  console.log(`\n  ðŸ“š Need to fetch docs for: ${technology.label}`);
  console.log(`     Context7 ID: ${technology.context7}`);

  return {
    technology: technology.value,
    context7Id: technology.context7,
    needsMCPFetch: true
  };
}

// ============================================
// SKILL FILE GENERATION
// ============================================

function generateSkillMd(tech, docs) {
  const date = new Date().toISOString().split('T')[0];

  return `---
name: ${tech.value}
version: 1.0
context7: ${tech.context7 || 'null'}
generated: ${new Date().toISOString()}
learningCount: 0
successRate: null
---

# ${tech.label} Skill

**Version**: Auto-generated ${date}
**Context7 ID**: ${tech.context7 || 'N/A'}

## Overview

This skill provides patterns and conventions for ${tech.label} development.
${docs?.overview || `Patterns extracted from ${tech.label} documentation.`}

## When to Apply

Apply this skill when:
- Working on files related to ${tech.label}
- Creating new ${tech.label} components/modules
- Reviewing ${tech.label} code

## Key Patterns

See \`knowledge/patterns.md\` for detailed patterns.

## Anti-Patterns to Avoid

See \`knowledge/anti-patterns.md\` for common mistakes.

## Conventions

See \`rules/conventions.md\` for coding standards.

---
*Auto-generated by Wogi Flow Tech Stack Wizard*
`;
}

function generatePatternsMd(tech, docs) {
  const keywords = TECH_KEYWORDS[tech.value] || [];
  const keywordsSection = keywords.length > 0
    ? `\n## Key Concepts\n\n${keywords.map(k => `- ${k}`).join('\n')}\n`
    : '';

  return `# ${tech.label} Patterns

Best practices and patterns for ${tech.label} development.
${keywordsSection}
## Patterns

${docs?.patterns || `### Pattern 1: [To be populated]

When fetching documentation via Context7, patterns will be extracted automatically.

### Pattern 2: [To be populated]

Run \`/wogi-setup-stack --regenerate\` after documentation is fetched.
`}

## Examples

${docs?.examples || `Examples will be populated from documentation.`}

---
*Auto-generated - will be enhanced with Context7 documentation*
`;
}

function generateAntiPatternsMd(tech, docs) {
  return `# ${tech.label} Anti-Patterns

Common mistakes and pitfalls to avoid with ${tech.label}.

## Anti-Patterns

${docs?.antiPatterns || `### Anti-Pattern 1: [To be populated]

Anti-patterns will be extracted from ${tech.label} documentation.

### Anti-Pattern 2: [To be populated]

Common mistakes identified in documentation and community discussions.
`}

## Why to Avoid

${docs?.whyAvoid || `Each anti-pattern includes reasoning for why it should be avoided.`}

---
*Auto-generated - will be enhanced with Context7 documentation*
`;
}

function generateConventionsMd(tech, docs) {
  return `# ${tech.label} Conventions

Coding standards and conventions for ${tech.label}.

## Naming Conventions

${docs?.naming || `- Follow ${tech.label} community conventions
- Use consistent naming across the codebase`}

## File Structure

${docs?.fileStructure || `Follow the recommended ${tech.label} project structure.`}

## Code Style

${docs?.codeStyle || `- Follow official ${tech.label} style guide
- Use linting tools where available`}

---
*Auto-generated - will be enhanced with Context7 documentation*
`;
}

// ============================================
// SKILLS INDEX GENERATION
// ============================================

function generateSkillsIndex(technologies, selections) {
  const skills = {};

  for (const tech of technologies) {
    const skillId = tech.value.toLowerCase().replace(/[^a-z0-9]/g, '-');
    const keywords = TECH_KEYWORDS[tech.value] || [];

    skills[skillId] = {
      path: `skills/${skillId}/`,
      label: tech.label,
      context7: tech.context7,
      covers: [tech.value, tech.label.toLowerCase(), ...keywords],
      sections: {
        overview: 'skill.md',
        patterns: 'knowledge/patterns.md',
        antiPatterns: 'knowledge/anti-patterns.md',
        conventions: 'rules/conventions.md'
      }
    };
  }

  // Determine project stack from selections
  const projectStack = technologies.map(t => t.value);

  return {
    version: '1.0',
    generated: new Date().toISOString(),
    projectType: selections.projectType,
    focus: selections.focus,
    skills,
    projectStack
  };
}

// ============================================
// MIGRATION: .claude/skills/ -> skills/
// ============================================

/**
 * Migrate skills from old .claude/skills/ location to new skills/ location
 * Called during skill generation to ensure consistency
 */
function migrateOldSkills(projectRoot) {
  const oldSkillsDir = path.join(projectRoot, '.claude', 'skills');
  const newSkillsDir = path.join(projectRoot, 'skills');

  if (!fs.existsSync(oldSkillsDir)) {
    return { migrated: [], skipped: [] };
  }

  const migrated = [];
  const skipped = [];

  try {
    const entries = fs.readdirSync(oldSkillsDir, { withFileTypes: true });

    for (const entry of entries) {
      // Skip non-directories and special files
      if (!entry.isDirectory()) {
        // Handle skills-index.json specially
        if (entry.name === 'skills-index.json') {
          const oldPath = path.join(oldSkillsDir, entry.name);
          const newPath = path.join(newSkillsDir, entry.name);

          // Only migrate if new one doesn't exist
          if (!fs.existsSync(newPath)) {
            ensureDir(newSkillsDir);
            fs.renameSync(oldPath, newPath);
            migrated.push(`skills-index.json`);
          } else {
            fs.unlinkSync(oldPath);
            skipped.push(`skills-index.json (newer exists)`);
          }
        }
        continue;
      }

      const skillName = entry.name;
      const oldSkillPath = path.join(oldSkillsDir, skillName);
      const newSkillPath = path.join(newSkillsDir, skillName);

      // Check if skill already exists in new location
      if (fs.existsSync(newSkillPath)) {
        // Skill exists in both places - keep new, remove old
        fs.rmSync(oldSkillPath, { recursive: true, force: true });
        skipped.push(`${skillName} (already in skills/)`);
      } else {
        // Move skill to new location
        ensureDir(newSkillsDir);
        fs.renameSync(oldSkillPath, newSkillPath);
        migrated.push(skillName);
      }
    }

    // Clean up empty .claude/skills directory
    const remainingEntries = fs.readdirSync(oldSkillsDir);
    if (remainingEntries.length === 0) {
      fs.rmdirSync(oldSkillsDir);
    }

  } catch (error) {
    console.warn(`  Warning: Could not migrate old skills: ${error.message}`);
  }

  return { migrated, skipped };
}

// ============================================
// FILE WRITING
// ============================================

function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

async function writeSkillFiles(tech, docs, projectRoot) {
  const skillId = tech.value.toLowerCase().replace(/[^a-z0-9]/g, '-');
  const skillDir = path.join(projectRoot, 'skills', skillId);

  // Create directory structure
  ensureDir(skillDir);
  ensureDir(path.join(skillDir, 'knowledge'));
  ensureDir(path.join(skillDir, 'rules'));
  ensureDir(path.join(skillDir, 'templates'));

  // Write skill files
  const files = [
    { path: 'skill.md', content: generateSkillMd(tech, docs) },
    { path: 'knowledge/patterns.md', content: generatePatternsMd(tech, docs) },
    { path: 'knowledge/anti-patterns.md', content: generateAntiPatternsMd(tech, docs) },
    { path: 'knowledge/learnings.md', content: `# ${tech.label} Learnings\n\n*Empty - will be populated as you provide feedback during development.*\n` },
    { path: 'rules/conventions.md', content: generateConventionsMd(tech, docs) }
  ];

  for (const file of files) {
    const filePath = path.join(skillDir, file.path);
    fs.writeFileSync(filePath, file.content, 'utf8');
  }

  return skillDir;
}

function updateDecisionsMd(selections, technologies, projectRoot) {
  const decisionsPath = path.join(projectRoot, '.workflow', 'state', 'decisions.md');

  // Build tech stack section
  const lines = [
    '\n## Tech Stack (auto-generated)\n',
    `*Generated: ${new Date().toISOString().split('T')[0]}*\n`
  ];

  if (selections.frontend && selections.frontend !== 'none') {
    const frontendOpt = technologies.find(t => t.value === selections.frontend);
    lines.push(`- **Frontend**: ${frontendOpt?.label || selections.frontend}`);
  }

  if (selections.stateManagement && selections.stateManagement !== 'none') {
    const stateOpt = technologies.find(t => t.value === selections.stateManagement);
    lines.push(`- **State Management**: ${stateOpt?.label || selections.stateManagement}`);
  }

  if (selections.styling && selections.styling !== 'none') {
    const { STYLING_OPTIONS } = require('./flow-stack-wizard');
    const styleOpt = STYLING_OPTIONS?.find(o => o.value === selections.styling);
    lines.push(`- **Styling**: ${styleOpt?.label || selections.styling}`);
  }

  if (selections.backend && selections.backend !== 'none') {
    const backendOpt = technologies.find(t => t.value === selections.backend);
    lines.push(`- **Backend**: ${backendOpt?.label || selections.backend}`);
  }

  if (selections.database && selections.database !== 'none') {
    const dbOpt = technologies.find(t => t.value === selections.database);
    lines.push(`- **Database**: ${dbOpt?.label || selections.database}`);
  }

  if (selections.testing && selections.testing !== 'none') {
    const { TESTING_OPTIONS } = require('./flow-stack-wizard');
    const testOpt = TESTING_OPTIONS?.find(o => o.value === selections.testing);
    lines.push(`- **Testing**: ${testOpt?.label || selections.testing}`);
  }

  if (selections.additionalTools?.length > 0) {
    lines.push(`- **Additional Tools**: ${selections.additionalTools.join(', ')}`);
  }

  lines.push('\nSee `skills/skills-index.json` for detailed patterns.\n');

  const techStackSection = lines.join('\n');

  // Read existing decisions.md or create new
  let content = '';
  if (fs.existsSync(decisionsPath)) {
    content = fs.readFileSync(decisionsPath, 'utf8');

    // Remove existing tech stack section if present
    const techStackRegex = /\n## Tech Stack \(auto-generated\)[\s\S]*?(?=\n## |$)/;
    content = content.replace(techStackRegex, '');
  } else {
    content = `# Project Decisions\n\nProject-specific coding decisions and patterns.\n`;
    ensureDir(path.dirname(decisionsPath));
  }

  // Append tech stack section
  content = content.trimEnd() + '\n' + techStackSection;

  fs.writeFileSync(decisionsPath, content, 'utf8');
}

function updateConfigJson(technologies, projectRoot) {
  const configPath = path.join(projectRoot, '.workflow', 'config.json');

  if (!fs.existsSync(configPath)) {
    console.log('  Warning: config.json not found, skipping skills registration');
    return;
  }

  const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));

  // Update skills section
  if (!config.skills) config.skills = {};
  config.skills.installed = technologies.map(t =>
    t.value.toLowerCase().replace(/[^a-z0-9]/g, '-')
  );

  fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf8');
}

// ============================================
// MAIN GENERATION FUNCTION
// ============================================

async function generateSkills(technologies, selections) {
  const projectRoot = process.cwd();

  // Migrate any skills from old .claude/skills/ location
  const migration = migrateOldSkills(projectRoot);
  if (migration.migrated.length > 0) {
    console.log('\n  Migrated skills from .claude/skills/ to skills/:');
    for (const skill of migration.migrated) {
      console.log(`    âœ“ ${skill}`);
    }
  }
  if (migration.skipped.length > 0) {
    console.log('\n  Cleaned up old skill locations:');
    for (const skill of migration.skipped) {
      console.log(`    - ${skill}`);
    }
  }

  console.log('\n  Generating skills for:');
  for (const tech of technologies) {
    console.log(`    - ${tech.label}`);
  }

  // Track what needs MCP fetching
  const needsMCPFetch = [];

  // Generate skill files for each technology
  for (const tech of technologies) {
    console.log(`\n  Processing ${tech.label}...`);

    // Try to fetch docs (will return null in MCP mode)
    const docResult = await fetchDocsViaContext7(tech);

    if (docResult?.needsMCPFetch) {
      needsMCPFetch.push(docResult);
    }

    // Generate placeholder skill files
    const skillDir = await writeSkillFiles(tech, null, projectRoot);
    console.log(`    âœ“ Created: ${path.relative(projectRoot, skillDir)}`);
  }

  // Generate skills index
  const skillsIndex = generateSkillsIndex(technologies, selections);
  const indexPath = path.join(projectRoot, 'skills', 'skills-index.json');
  ensureDir(path.dirname(indexPath));
  fs.writeFileSync(indexPath, JSON.stringify(skillsIndex, null, 2), 'utf8');
  console.log(`\n  âœ“ Created: skills/skills-index.json`);

  // Update decisions.md
  updateDecisionsMd(selections, technologies, projectRoot);
  console.log(`  âœ“ Updated: .workflow/state/decisions.md`);

  // Update config.json
  updateConfigJson(technologies, projectRoot);
  console.log(`  âœ“ Updated: .workflow/config.json`);

  // If running outside of Claude, provide MCP instructions
  if (needsMCPFetch.length > 0) {
    console.log('\n' + '='.repeat(60));
    console.log('  Documentation Fetch Required');
    console.log('='.repeat(60));
    console.log('\n  Skill placeholders created. To populate with real documentation:');
    console.log('\n  1. In Claude Code, run:');
    console.log('     /wogi-setup-stack --fetch-docs\n');
    console.log('  2. Claude will use Context7 MCP to fetch latest docs for:');
    for (const tech of needsMCPFetch) {
      console.log(`     - ${tech.technology} (${tech.context7Id})`);
    }
    console.log('\n  3. Skills will be updated with extracted patterns.');
    console.log();
  }

  return {
    skillsCreated: technologies.map(t => t.value),
    indexPath,
    needsMCPFetch
  };
}

/**
 * Enhance a skill with documentation from Context7
 * Called by Claude after fetching docs via MCP
 */
async function enhanceSkillWithDocs(skillId, docs) {
  const projectRoot = process.cwd();
  const skillDir = path.join(projectRoot, 'skills', skillId);

  if (!fs.existsSync(skillDir)) {
    throw new Error(`Skill directory not found: ${skillDir}`);
  }

  // Parse the docs to extract patterns, anti-patterns, etc.
  const parsed = parseDocumentation(docs);

  // Update patterns.md
  if (parsed.patterns) {
    const patternsPath = path.join(skillDir, 'knowledge', 'patterns.md');
    let content = fs.readFileSync(patternsPath, 'utf8');

    // Replace placeholder patterns
    content = content.replace(
      /## Patterns[\s\S]*?(?=## Examples|---)/,
      `## Patterns\n\n${parsed.patterns}\n\n`
    );

    if (parsed.examples) {
      content = content.replace(
        /## Examples[\s\S]*?(?=---)/,
        `## Examples\n\n${parsed.examples}\n\n`
      );
    }

    fs.writeFileSync(patternsPath, content, 'utf8');
  }

  // Update anti-patterns.md
  if (parsed.antiPatterns) {
    const antiPatternsPath = path.join(skillDir, 'knowledge', 'anti-patterns.md');
    let content = fs.readFileSync(antiPatternsPath, 'utf8');

    content = content.replace(
      /## Anti-Patterns[\s\S]*?(?=## Why|---)/,
      `## Anti-Patterns\n\n${parsed.antiPatterns}\n\n`
    );

    fs.writeFileSync(antiPatternsPath, content, 'utf8');
  }

  // Update conventions.md
  if (parsed.conventions) {
    const conventionsPath = path.join(skillDir, 'rules', 'conventions.md');
    fs.writeFileSync(conventionsPath, parsed.conventions, 'utf8');
  }

  return { enhanced: true, skillId };
}

/**
 * Parse documentation text to extract patterns, anti-patterns, and conventions
 */
function parseDocumentation(docs) {
  // Simple parsing - in practice, Claude would do intelligent extraction
  const result = {
    patterns: null,
    antiPatterns: null,
    conventions: null,
    examples: null
  };

  if (typeof docs === 'string') {
    // Look for common section headers
    const patternsMatch = docs.match(/(?:best practices|patterns|recommended)[\s\S]*?(?=\n#|$)/i);
    if (patternsMatch) result.patterns = patternsMatch[0];

    const antiMatch = docs.match(/(?:anti-patterns|avoid|common mistakes|pitfalls)[\s\S]*?(?=\n#|$)/i);
    if (antiMatch) result.antiPatterns = antiMatch[0];

    const examplesMatch = docs.match(/(?:examples|usage|code samples)[\s\S]*?(?=\n#|$)/i);
    if (examplesMatch) result.examples = examplesMatch[0];
  } else if (typeof docs === 'object') {
    // Accept pre-parsed docs
    result.patterns = docs.patterns;
    result.antiPatterns = docs.antiPatterns;
    result.conventions = docs.conventions;
    result.examples = docs.examples;
  }

  return result;
}

// ============================================
// EXPORTS
// ============================================

module.exports = {
  generateSkills,
  enhanceSkillWithDocs,
  parseDocumentation,
  generateSkillsIndex,
  migrateOldSkills,
  SKILL_TOPICS,
  TECH_KEYWORDS
};

// CLI support
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.includes('--help')) {
    console.log(`
Skill Generator for Wogi Flow

Usage:
  node flow-skill-generator.js [options]

Options:
  --from-selections    Generate from saved stack-selections.json
  --help               Show this help

This script is typically called by the Tech Stack Wizard.
For manual use, run the wizard first: node flow-stack-wizard.js
`);
    process.exit(0);
  }

  if (args.includes('--from-selections')) {
    const selectionsPath = path.join(process.cwd(), '.workflow', 'state', 'stack-selections.json');

    if (!fs.existsSync(selectionsPath)) {
      console.error('No stack-selections.json found. Run the wizard first.');
      process.exit(1);
    }

    const selections = JSON.parse(fs.readFileSync(selectionsPath, 'utf8'));
    const { StackWizard } = require('./flow-stack-wizard');
    const wizard = new StackWizard();
    wizard.selections = selections;
    const technologies = wizard.collectTechnologies();

    generateSkills(technologies, selections)
      .then(() => process.exit(0))
      .catch((err) => {
        console.error('Error:', err);
        process.exit(1);
      });
  }
}
