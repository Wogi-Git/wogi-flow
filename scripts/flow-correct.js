#!/usr/bin/env node

/**
 * Wogi Flow - Capture Corrections
 *
 * Records corrections/learnings to ensure they are preserved and tracked.
 * Supports both interactive and quick CLI modes.
 *
 * Usage:
 *   flow correct                          # Interactive mode
 *   flow correct "brief description"      # Quick mode
 *   flow correct --task TASK-XXX "desc"   # Link to task
 *   flow correct --skill nestjs "desc"    # Link to skill
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const {
  PATHS,
  PROJECT_ROOT,
  fileExists,
  dirExists,
  readFile,
  writeFile,
  color,
  success,
  warn,
  error
} = require('./flow-utils');

// ============================================================
// Paths
// ============================================================

function getCorrectionsDir() {
  try {
    const config = JSON.parse(fs.readFileSync(PATHS.config, 'utf-8'));
    const detailPath = config?.corrections?.detailPath;
    if (detailPath) {
      return path.isAbsolute(detailPath) ? detailPath : path.join(PROJECT_ROOT, detailPath);
    }
  } catch (e) {
    // Fall back to default if config can't be read
  }
  return path.join(PROJECT_ROOT, '.workflow', 'corrections');
}

const CORRECTIONS_DIR = getCorrectionsDir();

// ============================================================
// Interactive Prompt Utilities
// ============================================================

function createInterface() {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
}

function prompt(rl, question, defaultValue = '') {
  return new Promise((resolve) => {
    const suffix = defaultValue ? ` (${defaultValue})` : '';
    rl.question(`${question}${suffix}: `, (answer) => {
      resolve(answer.trim() || defaultValue);
    });
  });
}

function promptMultiline(rl, question) {
  return new Promise((resolve) => {
    console.log(`${question} (end with empty line):`);
    const lines = [];

    const readLine = () => {
      rl.question('  ', (line) => {
        if (line === '') {
          resolve(lines.join('\n'));
        } else {
          lines.push(line);
          readLine();
        }
      });
    };

    readLine();
  });
}

// ============================================================
// Core Functions
// ============================================================

/**
 * Generate next correction ID
 */
function getNextCorrectionId() {
  if (!dirExists(CORRECTIONS_DIR)) {
    fs.mkdirSync(CORRECTIONS_DIR, { recursive: true });
    return 'CORR-001';
  }

  const files = fs.readdirSync(CORRECTIONS_DIR)
    .filter(f => f.startsWith('CORR-') && f.endsWith('.md'));

  if (files.length === 0) {
    return 'CORR-001';
  }

  const numbers = files.map(f => {
    const match = f.match(/CORR-(\d+)/);
    return match ? parseInt(match[1], 10) : 0;
  });

  const maxNum = Math.max(...numbers);
  return `CORR-${String(maxNum + 1).padStart(3, '0')}`;
}

/**
 * Create correction file
 */
function createCorrectionFile(data) {
  const {
    id,
    brief,
    whatHappened,
    whatShouldHappen,
    rootCause,
    taskId,
    skillName,
    files,
    tags
  } = data;

  const date = new Date().toISOString().split('T')[0];
  const timestamp = new Date().toISOString();

  const content = `# ${id} - ${brief}

**Date**: ${date}
**Timestamp**: ${timestamp}
${taskId ? `**Task**: ${taskId}` : ''}
${skillName ? `**Skill**: ${skillName}` : ''}
${tags.length > 0 ? `**Tags**: ${tags.map(t => `#${t}`).join(' ')}` : ''}

## What Happened

${whatHappened || '_Not specified_'}

## What Should Happen

${whatShouldHappen || '_Not specified_'}

## Root Cause

${rootCause || '_Not specified_'}

${files.length > 0 ? `## Files Affected\n\n${files.map(f => `- \`${f}\``).join('\n')}` : ''}

## Status

- [ ] Pattern identified
- [ ] Added to knowledge base
- [ ] Promoted to instruction file (if pattern repeats)

---

_Generated by \`flow correct\`_
`;

  const filePath = path.join(CORRECTIONS_DIR, `${id}.md`);
  writeFile(filePath, content);
  return filePath;
}

/**
 * Update feedback-patterns.md with the correction
 */
function updateFeedbackPatterns(brief, taskId, skillName) {
  const date = new Date().toISOString().split('T')[0];

  let content = readFile(PATHS.feedbackPatterns, '');

  // Check if similar correction exists (simple substring match)
  const briefLower = brief.toLowerCase();
  const lines = content.split('\n');
  let existingIndex = -1;
  let existingCount = 1;

  // Look in the table for similar entries
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.startsWith('|') && !line.includes('---') && !line.includes('Date')) {
      const cells = line.split('|').map(c => c.trim());
      if (cells[2] && cells[2].toLowerCase().includes(briefLower.slice(0, 20))) {
        // Found similar entry, extract count
        existingIndex = i;
        const countMatch = cells[3]?.match(/(\d+)/);
        existingCount = countMatch ? parseInt(countMatch[1], 10) + 1 : 2;
        break;
      }
    }
  }

  if (existingIndex > 0) {
    // Update existing entry count
    const cells = lines[existingIndex].split('|');
    cells[1] = ` ${date} `;
    cells[3] = ` ${existingCount} `;
    lines[existingIndex] = cells.join('|');
    content = lines.join('\n');
  } else {
    // Add new entry after the example row
    const tableIndex = content.indexOf('| _example_');
    if (tableIndex > -1) {
      const lineEnd = content.indexOf('\n', tableIndex);
      const newRow = `\n| ${date} | "${brief.slice(0, 40)}${brief.length > 40 ? '...' : ''}" | 1 | - | Pending |`;
      content = content.slice(0, lineEnd) + newRow + content.slice(lineEnd);
    }
  }

  writeFile(PATHS.feedbackPatterns, content);
  return existingCount;
}

/**
 * Update skill learnings if skill is specified
 */
function updateSkillLearnings(skillName, data) {
  const skillDir = path.join(PROJECT_ROOT, '.claude', 'skills', skillName, 'knowledge');
  const learningsPath = path.join(skillDir, 'learnings.md');

  if (!dirExists(skillDir)) {
    warn(`Skill directory not found: ${skillDir}`);
    return false;
  }

  const date = new Date().toISOString().split('T')[0];

  let content = readFile(learningsPath, '# Learnings\n\n');

  const entry = `
### ${date} - ${data.brief}

**Context**: ${data.whatHappened || 'Correction captured via CLI'}
**Trigger**: manual
**Issue**: ${data.rootCause || 'See correction file'}
**Learning**: ${data.whatShouldHappen || 'See correction file'}
**Files**: ${data.files.join(', ') || 'N/A'}
`;

  // Append after the header
  if (content.includes('# Learnings')) {
    content = content.replace('# Learnings', `# Learnings\n${entry}`);
  } else {
    content += entry;
  }

  writeFile(learningsPath, content);
  return true;
}

// ============================================================
// Interactive Mode
// ============================================================

async function runInteractive() {
  const rl = createInterface();

  console.log(color('cyan', '═══════════════════════════════════════════'));
  console.log(color('cyan', '         Capture Correction'));
  console.log(color('cyan', '═══════════════════════════════════════════'));
  console.log('');

  try {
    const brief = await prompt(rl, 'Brief description');
    if (!brief) {
      error('Brief description is required');
      rl.close();
      process.exit(1);
    }

    const whatHappened = await promptMultiline(rl, 'What happened (the mistake)');
    const whatShouldHappen = await promptMultiline(rl, 'What should happen instead');
    const rootCause = await prompt(rl, 'Root cause (optional)');
    const taskId = await prompt(rl, 'Related task ID (optional)');
    const skillName = await prompt(rl, 'Related skill name (optional)');
    const filesStr = await prompt(rl, 'Affected files (comma-separated, optional)');
    const tagsStr = await prompt(rl, 'Tags (comma-separated, optional)');

    const files = filesStr ? filesStr.split(',').map(f => f.trim()) : [];
    const tags = tagsStr ? tagsStr.split(',').map(t => t.trim()) : [];

    rl.close();

    // Create correction
    const id = getNextCorrectionId();
    const data = {
      id,
      brief,
      whatHappened,
      whatShouldHappen,
      rootCause,
      taskId,
      skillName,
      files,
      tags
    };

    const filePath = createCorrectionFile(data);
    const count = updateFeedbackPatterns(brief, taskId, skillName);

    if (skillName) {
      updateSkillLearnings(skillName, data);
    }

    console.log('');
    success(`Correction saved: ${id}`);
    console.log(`  File: ${filePath}`);
    console.log(`  Pattern count: ${count}`);

    if (count >= 3) {
      console.log('');
      warn('This pattern has occurred 3+ times!');
      console.log('  Consider promoting to an instruction file:');
      console.log('  - decisions.md (project rules)');
      console.log('  - agents/*.md (process changes)');
      console.log('  - CLAUDE.md (core workflow)');
    }

  } catch (err) {
    rl.close();
    error(`Failed: ${err.message}`);
    process.exit(1);
  }
}

// ============================================================
// Quick Mode
// ============================================================

function runQuick(brief, options) {
  const { taskId, skillName } = options;

  const id = getNextCorrectionId();
  const data = {
    id,
    brief,
    whatHappened: '',
    whatShouldHappen: '',
    rootCause: '',
    taskId: taskId || '',
    skillName: skillName || '',
    files: [],
    tags: []
  };

  const filePath = createCorrectionFile(data);
  const count = updateFeedbackPatterns(brief, taskId, skillName);

  if (skillName) {
    updateSkillLearnings(skillName, data);
  }

  success(`Correction saved: ${id}`);
  console.log(`  File: ${filePath}`);
  console.log(`  Pattern count: ${count}`);

  if (count >= 3) {
    console.log('');
    warn('This pattern has occurred 3+ times - consider promoting to instruction file');
  }
}

// ============================================================
// List Mode
// ============================================================

function listCorrections() {
  if (!dirExists(CORRECTIONS_DIR)) {
    console.log('No corrections recorded yet.');
    return;
  }

  const files = fs.readdirSync(CORRECTIONS_DIR)
    .filter(f => f.startsWith('CORR-') && f.endsWith('.md'))
    .sort()
    .reverse();

  if (files.length === 0) {
    console.log('No corrections recorded yet.');
    return;
  }

  console.log(color('cyan', 'Recent Corrections'));
  console.log('');

  for (const file of files.slice(0, 10)) {
    const content = readFile(path.join(CORRECTIONS_DIR, file), '');
    const titleMatch = content.match(/^# (CORR-\d+) - (.+)$/m);
    const dateMatch = content.match(/\*\*Date\*\*: (.+)$/m);

    const id = titleMatch ? titleMatch[1] : file.replace('.md', '');
    const title = titleMatch ? titleMatch[2] : 'Unknown';
    const date = dateMatch ? dateMatch[1] : 'Unknown';

    console.log(`  ${color('yellow', id)} | ${date} | ${title.slice(0, 50)}`);
  }

  if (files.length > 10) {
    console.log('');
    console.log(`  ... and ${files.length - 10} more`);
  }
}

// ============================================================
// Main
// ============================================================

function main() {
  const args = process.argv.slice(2);

  // Parse options
  let taskId = '';
  let skillName = '';
  let brief = '';
  let listMode = false;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--task' && args[i + 1]) {
      taskId = args[i + 1];
      i++;
    } else if (args[i] === '--skill' && args[i + 1]) {
      skillName = args[i + 1];
      i++;
    } else if (args[i] === 'list' || args[i] === '--list') {
      listMode = true;
    } else if (!args[i].startsWith('-')) {
      brief = args[i];
    }
  }

  if (listMode) {
    listCorrections();
    return;
  }

  if (brief) {
    // Quick mode
    runQuick(brief, { taskId, skillName });
  } else {
    // Interactive mode
    runInteractive();
  }
}

main();
