#!/bin/bash

# Wogi Flow - Interactive Installer
# Sets up workflow with user preferences

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WORKFLOW_DIR=".workflow"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Default values
PROJECT_NAME=""
IS_EXISTING_PROJECT=false
DETECTED_FRAMEWORK=""
DETECTED_LANGUAGE=""
DETECTED_DATABASE=""
DETECTED_COMPONENTS=0
AGENT_STRUCTURE="unified"
CORRECTION_MODE="hybrid"
PLANNING_STYLE="feature-based"
SKILLS=""
ENABLE_HOOKS=false
ENABLE_STORYBOOK=false
STRICT_VERIFICATION=false
STRICT_CORRECTIONS=false
STRICT_REPORTS=false
RUN_STACK_WIZARD=false

print_header() {
    clear
    echo -e "${CYAN}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë                                                               ‚ïë"
    echo "‚ïë               üöÄ Wogi Flow Installer v3.0 üöÄ                  ‚ïë"
    echo "‚ïë                                                               ‚ïë"
    echo "‚ïë     Self-improving AI Development Workflow                    ‚ïë"
    echo "‚ïë                                                               ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${NC}"
    echo ""
}

# Check if already initialized
check_existing() {
    if [ -d "$WORKFLOW_DIR" ]; then
        echo -e "${YELLOW}‚ö† Wogi Flow is already installed in this directory.${NC}"
        echo ""
        read -p "Do you want to reconfigure? (y/n): " reconfigure
        if [[ ! "$reconfigure" =~ ^[Yy]$ ]]; then
            echo "Installation cancelled."
            exit 0
        fi
        echo ""
    fi
}

# Question 0: Setup type (fresh vs import)
ask_setup_type() {
    echo -e "${BOLD}How would you like to set up Wogi Flow?${NC}"
    echo ""
    echo "   (1) Fresh start - New configuration with guided setup"
    echo "   (2) Import from profile - Use existing team/project profile"
    echo "   (3) Quick setup - Defaults without questions"
    echo ""

    read -p "   Choice [1]: " setup_choice
    case "$setup_choice" in
        2)
            import_from_profile
            ;;
        3)
            quick_install
            exit 0
            ;;
        *)
            # Continue with normal flow
            return 0
            ;;
    esac
}

# Import from existing profile
import_from_profile() {
    echo ""
    echo -e "${CYAN}Import from Profile${NC}"
    echo ""
    echo "   Enter the path to your profile (zip file):"
    echo "   Example: ~/my-team-profile.zip or ./wogi-profiles/team.zip"
    echo ""

    read -p "   Profile path: " profile_path

    if [ -z "$profile_path" ]; then
        echo -e "${YELLOW}No profile specified. Continuing with fresh setup.${NC}"
        echo ""
        return 0
    fi

    # Expand ~ to home directory
    profile_path="${profile_path/#\~/$HOME}"

    if [ ! -f "$profile_path" ]; then
        echo -e "${RED}Profile not found: $profile_path${NC}"
        echo ""
        read -p "   Continue with fresh setup? (y/n): " continue_fresh
        if [[ "$continue_fresh" =~ ^[Yy]$ ]]; then
            return 0
        else
            exit 1
        fi
    fi

    echo ""
    echo -e "${CYAN}Importing profile...${NC}"
    echo ""

    # Run import-profile script
    if "$SCRIPT_DIR/flow-import-profile" "$profile_path" --force; then
        echo ""
        echo -e "${GREEN}‚úì Profile imported successfully!${NC}"
        echo ""

        # Ask if they want to continue with onboarding
        read -p "   Continue with project onboarding to customize for this project? (Y/n): " continue_onboard

        if [[ ! "$continue_onboard" =~ ^[Nn]$ ]]; then
            echo ""
            echo -e "${CYAN}Running onboarding...${NC}"
            echo ""
            "$SCRIPT_DIR/flow-onboard"
        fi

        # Print completion and exit
        echo ""
        echo -e "${GREEN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
        echo -e "${GREEN}‚ïë           ‚úÖ Setup complete with imported profile!            ‚ïë${NC}"
        echo -e "${GREEN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
        echo ""
        echo -e "${BOLD}Next steps:${NC}"
        echo "  1. Review imported config: ${CYAN}cat .workflow/config.json${NC}"
        echo "  2. Check workflow health:  ${CYAN}/wogi-health${NC}"
        echo "  3. See available tasks:    ${CYAN}/wogi-ready${NC}"
        echo ""
        exit 0
    else
        echo -e "${RED}Import failed. Continuing with fresh setup.${NC}"
        echo ""
        return 0
    fi
}

# Quick install (non-interactive)
quick_install() {
    local project_name="${PROJECT_NAME:-$(basename "$(pwd)")}"
    create_structure
    PROJECT_NAME="$project_name"
    generate_config
    generate_state_files
    copy_core_files
    migrate_old_skills

    # Auto-install LSP dependencies for Node.js projects (non-interactive)
    if [ -f "package.json" ]; then
        if ! command -v typescript-language-server &> /dev/null && [ ! -f "node_modules/.bin/typescript-language-server" ]; then
            echo -e "${CYAN}Installing LSP dependencies...${NC}"
            npm install --save-dev typescript-language-server typescript 2>/dev/null && \
                echo -e "  ${GREEN}‚úì${NC} typescript-language-server installed" || \
                echo -e "  ${YELLOW}‚óã${NC} LSP install skipped (run: npm i -D typescript-language-server typescript)"
        fi
    fi

    echo -e "${GREEN}‚úì Quick install complete${NC}"
    echo ""
    echo -e "${YELLOW}‚ö†Ô∏è  STRICT MODE ENABLED (default)${NC}"
    echo -e "   Claude will STOP before implementation to create tasks/stories."
    echo -e "   To disable: edit .workflow/config.json ‚Üí enforcement.strictMode"
    echo ""
    echo -e "${CYAN}üí° Tip:${NC} Run /wogi-setup-stack to configure your tech stack."
}

# Question 1: Project name
ask_project_name() {
    echo -e "${BOLD}1. Project Name${NC}"
    echo "   Enter a name for your project (used in docs and commits)"
    echo ""
    
    # Try to get from package.json or directory name
    local default_name=""
    if [ -f "package.json" ]; then
        default_name=$(python3 -c "import json; print(json.load(open('package.json')).get('name', ''))" 2>/dev/null || echo "")
    fi
    if [ -z "$default_name" ]; then
        default_name=$(basename "$(pwd)")
    fi
    
    read -p "   Project name [$default_name]: " PROJECT_NAME
    PROJECT_NAME="${PROJECT_NAME:-$default_name}"
    echo ""
}

# Question 2: Project type (new vs existing)
ask_project_type() {
    echo -e "${BOLD}2. Project Type${NC}"
    echo "   Is this a new project or an existing one?"
    echo ""
    echo "   (a) New project - Start fresh with guided setup"
    echo "   (b) Existing project - Analyze and configure based on codebase"
    echo ""

    read -p "   Choice [a]: " choice
    case "$choice" in
        b|B)
            IS_EXISTING_PROJECT=true
            echo ""
            echo -e "${CYAN}Analyzing project...${NC}"
            run_project_detection
            ;;
        *) IS_EXISTING_PROJECT=false ;;
    esac
    echo ""
}

# Detection functions for existing projects
detect_language() {
    if [ -f "tsconfig.json" ]; then
        echo "TypeScript"
    elif [ -f "package.json" ]; then
        echo "JavaScript"
    elif [ -f "requirements.txt" ] || [ -f "setup.py" ] || [ -f "pyproject.toml" ]; then
        echo "Python"
    elif [ -f "go.mod" ]; then
        echo "Go"
    elif [ -f "Cargo.toml" ]; then
        echo "Rust"
    elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
        echo "Java"
    else
        echo "unknown"
    fi
}

detect_framework() {
    local framework="unknown"

    if [ -f "package.json" ]; then
        if grep -q '"next"' package.json 2>/dev/null; then
            framework="nextjs"
        elif grep -q '"@nestjs/core"' package.json 2>/dev/null; then
            framework="nestjs"
        elif grep -q '"react-native"' package.json 2>/dev/null; then
            framework="react-native"
        elif grep -q '"expo"' package.json 2>/dev/null; then
            framework="expo"
        elif grep -q '"react"' package.json 2>/dev/null; then
            framework="react"
        elif grep -q '"vue"' package.json 2>/dev/null; then
            framework="vue"
        elif grep -q '"nuxt"' package.json 2>/dev/null; then
            framework="nuxt"
        elif grep -q '"@angular/core"' package.json 2>/dev/null; then
            framework="angular"
        elif grep -q '"svelte"' package.json 2>/dev/null; then
            framework="svelte"
        elif grep -q '"express"' package.json 2>/dev/null; then
            framework="express"
        elif grep -q '"fastify"' package.json 2>/dev/null; then
            framework="fastify"
        fi
    fi

    if [ -f "requirements.txt" ]; then
        if grep -qi "fastapi" requirements.txt 2>/dev/null; then
            framework="fastapi"
        elif grep -qi "django" requirements.txt 2>/dev/null; then
            framework="django"
        elif grep -qi "flask" requirements.txt 2>/dev/null; then
            framework="flask"
        fi
    fi

    # Check for specific config files
    if [ -f "next.config.js" ] || [ -f "next.config.mjs" ] || [ -f "next.config.ts" ]; then
        framework="nextjs"
    elif [ -f "nest-cli.json" ]; then
        framework="nestjs"
    elif [ -f "angular.json" ]; then
        framework="angular"
    elif [ -f "nuxt.config.js" ] || [ -f "nuxt.config.ts" ]; then
        framework="nuxt"
    elif [ -f "svelte.config.js" ]; then
        framework="svelte"
    fi

    echo "$framework"
}

detect_database() {
    local db=""

    if [ -f "package.json" ]; then
        if grep -q '"prisma"' package.json 2>/dev/null; then
            db="Prisma"
        elif grep -q '"typeorm"' package.json 2>/dev/null; then
            db="TypeORM"
        elif grep -q '"drizzle-orm"' package.json 2>/dev/null; then
            db="Drizzle"
        elif grep -q '"mongoose"' package.json 2>/dev/null; then
            db="MongoDB (Mongoose)"
        elif grep -q '"sequelize"' package.json 2>/dev/null; then
            db="Sequelize"
        fi
    fi

    if [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ]; then
        local docker_file="docker-compose.yml"
        [ -f "docker-compose.yaml" ] && docker_file="docker-compose.yaml"

        if grep -q "postgres" "$docker_file" 2>/dev/null; then
            db="${db:+$db + }PostgreSQL"
        fi
        if grep -q "mysql" "$docker_file" 2>/dev/null; then
            db="${db:+$db + }MySQL"
        fi
        if grep -q "mongo" "$docker_file" 2>/dev/null; then
            db="${db:+$db + }MongoDB"
        fi
        if grep -q "redis" "$docker_file" 2>/dev/null; then
            db="${db:+$db + }Redis"
        fi
    fi

    echo "${db:-unknown}"
}

count_components() {
    local count=0

    # Count React/Vue components
    if [ -d "src/components" ]; then
        count=$((count + $(find src/components -type f \( -name "*.tsx" -o -name "*.jsx" -o -name "*.vue" \) 2>/dev/null | wc -l)))
    fi

    # Count pages
    for dir in "src/pages" "pages" "app"; do
        if [ -d "$dir" ]; then
            count=$((count + $(find "$dir" -type f \( -name "*.tsx" -o -name "*.jsx" -o -name "*.vue" \) 2>/dev/null | wc -l)))
        fi
    done

    # Count NestJS modules
    if [ -d "src" ]; then
        count=$((count + $(find src -name "*.module.ts" 2>/dev/null | wc -l)))
    fi

    echo "$count"
}

run_project_detection() {
    DETECTED_LANGUAGE=$(detect_language)
    DETECTED_FRAMEWORK=$(detect_framework)
    DETECTED_DATABASE=$(detect_database)
    DETECTED_COMPONENTS=$(count_components)

    echo ""
    echo -e "${GREEN}Detected:${NC}"
    echo "  - Language:   $DETECTED_LANGUAGE"
    echo "  - Framework:  $DETECTED_FRAMEWORK"
    echo "  - Database:   $DETECTED_DATABASE"
    echo "  - Components: $DETECTED_COMPONENTS found"
    echo ""

    read -p "   Configure based on these detections? [Y/n]: " use_detected
    if [[ "${use_detected:-y}" =~ ^[Nn]$ ]]; then
        IS_EXISTING_PROJECT=false
        echo -e "   ${YELLOW}Will proceed with manual configuration.${NC}"
    else
        echo -e "   ${GREEN}Will pre-fill settings based on detection.${NC}"
    fi
}

# Question 3: Agent structure
ask_agent_structure() {
    echo -e "${BOLD}3. Agent Structure${NC}"
    echo "   How should development agents be organized?"
    echo ""
    echo "   (a) Unified - Single developer/reviewer/tester agents [Recommended]"
    echo "       Best for: Solo devs, small teams, fullstack developers"
    echo ""
    echo "   (b) Split - Separate frontend/backend agents"
    echo "       Best for: Large teams with specialists, complex projects"
    echo ""

    read -p "   Choice [a]: " choice
    case "$choice" in
        b|B) AGENT_STRUCTURE="split" ;;
        *) AGENT_STRUCTURE="unified" ;;
    esac
    echo ""
}

# Question 4: Correction report mode
ask_correction_mode() {
    echo -e "${BOLD}4. Correction Report Mode${NC}"
    echo "   How detailed should bug fix documentation be?"
    echo ""
    echo "   (a) Inline only - Everything in request-log.md"
    echo "       Quick entries, low overhead"
    echo ""
    echo "   (b) Hybrid - Summary in log, detailed doc for significant fixes [Recommended]"
    echo "       Balance of speed and thoroughness"
    echo ""
    echo "   (c) Always detailed - Summary + linked detailed doc for every fix"
    echo "       Maximum traceability, higher overhead"
    echo ""

    read -p "   Choice [b]: " choice
    case "$choice" in
        a|A) CORRECTION_MODE="inline" ;;
        c|C) CORRECTION_MODE="always-detailed" ;;
        *) CORRECTION_MODE="hybrid" ;;
    esac
    echo ""
}

# Question 5: Planning style
ask_planning_style() {
    echo -e "${BOLD}5. Planning Style${NC}"
    echo "   How should features and tasks be organized?"
    echo ""
    echo "   (a) Feature-based - Flexible, work on any feature [Recommended]"
    echo "       Best for: Ongoing products, agile teams, maintenance"
    echo ""
    echo "   (b) Phase-based - Sequential phases with milestones"
    echo "       Best for: New projects, fixed scope, waterfall-ish"
    echo ""

    read -p "   Choice [a]: " choice
    case "$choice" in
        b|B) PLANNING_STYLE="phase-based" ;;
        *) PLANNING_STYLE="feature-based" ;;
    esac
    echo ""
}

# Question 6: Tech Stack Wizard
ask_tech_stack() {
    echo -e "${BOLD}6. Tech Stack Configuration${NC}"
    echo "   Configure your tech stack to generate framework-specific skills?"
    echo ""
    echo "   This will:"
    echo "   - Ask about your frontend/backend frameworks"
    echo "   - Configure state management, styling, testing, etc."
    echo "   - Generate skills with best practices for your stack"
    echo "   - Fetch latest documentation via Context7"
    echo ""
    echo "   (a) Run tech stack wizard now [Recommended]"
    echo "   (b) Skip - I'll configure later with /wogi-setup-stack"
    echo ""

    read -p "   Choice [a]: " choice
    case "$choice" in
        b|B)
            echo -e "   ${YELLOW}Skipped.${NC} Run /wogi-setup-stack later to configure."
            SKILLS="none"
            ;;
        *)
            # Will run the wizard after confirmation
            RUN_STACK_WIZARD=true
            ;;
    esac
    echo ""
}

# Question 7: Optional features
ask_optional_features() {
    echo -e "${BOLD}7. Optional Features${NC}"
    echo "   Enable additional features? (y/n for each)"
    echo ""

    read -p "   Pre-commit git hooks? [n]: " choice
    [[ "$choice" =~ ^[Yy]$ ]] && ENABLE_HOOKS=true

    read -p "   Auto-generate Storybook stories? [n]: " choice
    [[ "$choice" =~ ^[Yy]$ ]] && ENABLE_STORYBOOK=true

    echo ""
    echo -e "${BOLD}   Strict Mode Options:${NC}"

    read -p "   Require verification checklist before done? [n]: " choice
    [[ "$choice" =~ ^[Yy]$ ]] && STRICT_VERIFICATION=true

    read -p "   Require correction reports on test failures? [n]: " choice
    [[ "$choice" =~ ^[Yy]$ ]] && STRICT_CORRECTIONS=true

    read -p "   Require feature reports on completion? [n]: " choice
    [[ "$choice" =~ ^[Yy]$ ]] && STRICT_REPORTS=true

    echo ""
}

# Show summary and confirm
confirm_settings() {
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${BOLD}                     Configuration Summary${NC}"
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
    echo "   Project Name:        $PROJECT_NAME"
    if [ "$IS_EXISTING_PROJECT" = true ]; then
        echo "   Project Type:        Existing project"
        echo "   Detected Framework:  $DETECTED_FRAMEWORK"
        echo "   Detected Language:   $DETECTED_LANGUAGE"
    else
        echo "   Project Type:        New project"
    fi
    echo "   Agent Structure:     $AGENT_STRUCTURE"
    echo "   Correction Mode:     $CORRECTION_MODE"
    echo "   Planning Style:      $PLANNING_STYLE"
    if [ "$RUN_STACK_WIZARD" = true ]; then
        echo "   Tech Stack:          Will configure with wizard"
    else
        echo "   Tech Stack:          Skip (configure later)"
    fi
    echo ""
    echo "   Optional Features:"
    echo "   - Pre-commit hooks:           $ENABLE_HOOKS"
    echo "   - Auto Storybook:             $ENABLE_STORYBOOK"
    echo "   - Strict verification:        $STRICT_VERIFICATION"
    echo "   - Strict correction reports:  $STRICT_CORRECTIONS"
    echo "   - Strict feature reports:     $STRICT_REPORTS"
    echo ""
    echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""

    read -p "Proceed with installation? (y/n): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Installation cancelled."
        exit 0
    fi
    echo ""
}

# Create directory structure
create_structure() {
    echo -e "${CYAN}Creating directory structure...${NC}"
    
    mkdir -p "$WORKFLOW_DIR/state/components"
    mkdir -p "$WORKFLOW_DIR/changes"
    mkdir -p "$WORKFLOW_DIR/bugs"
    mkdir -p "$WORKFLOW_DIR/corrections"
    mkdir -p "$WORKFLOW_DIR/archive"
    mkdir -p "$WORKFLOW_DIR/tests/flows"
    mkdir -p "$WORKFLOW_DIR/specs/capabilities"
    mkdir -p ".claude/commands"
    mkdir -p ".claude/rules"
    mkdir -p ".claude/docs"
    mkdir -p "skills"
    
    if [ "$AGENT_STRUCTURE" = "split" ]; then
        mkdir -p ".claude/agents/developer"
        mkdir -p ".claude/agents/reviewer"
        mkdir -p ".claude/agents/tester"
    else
        mkdir -p ".claude/agents"
    fi
    
    # Create .gitkeep files
    touch "$WORKFLOW_DIR/changes/.gitkeep"
    touch "$WORKFLOW_DIR/bugs/.gitkeep"
    touch "$WORKFLOW_DIR/corrections/.gitkeep"
    touch "$WORKFLOW_DIR/archive/.gitkeep"
    touch "$WORKFLOW_DIR/tests/flows/.gitkeep"
    touch "$WORKFLOW_DIR/specs/capabilities/.gitkeep"
    touch "$WORKFLOW_DIR/state/components/.gitkeep"
    
    echo -e "${GREEN}‚úì${NC} Directory structure created"
}

# Generate config.json
generate_config() {
    echo -e "${CYAN}Generating configuration...${NC}"

    cat > "$WORKFLOW_DIR/config.json" << EOF
{
  "version": "1.9",
  "projectName": "$PROJECT_NAME",

  "enforcement": {
    "strictMode": true,
    "requireTaskForImplementation": true,
    "requireStoryForMediumTasks": true,
    "taskSizeThresholds": {
      "small": { "maxFiles": 3, "maxHours": 1 },
      "medium": { "maxFiles": 10, "maxHours": 4 },
      "large": { "minFiles": 10, "minHours": 4 }
    }
  },

  "commits": {
    "requireApproval": {
      "feature": true,
      "bugfix": false,
      "refactor": true,
      "docs": false
    },
    "autoCommitSmallFixes": true,
    "smallFixThreshold": 3,
    "squashTaskCommits": true,
    "commitMessageFormat": "conventional"
  },

  "workflow": {
    "planningStyle": "$PLANNING_STYLE",
    "agentStructure": "$AGENT_STRUCTURE"
  },

  "loops": {
    "enabled": true,
    "maxRetries": 5,
    "maxIterations": 20,
    "commitEvery": 3,
    "pauseBetweenScenarios": false
  },

  "corrections": {
    "mode": "$CORRECTION_MODE",
    "detailPath": ".workflow/corrections"
  },

  "phases": {
    "enabled": $([ "$PLANNING_STYLE" = "phase-based" ] && echo "true" || echo "false"),
    "definitions": []
  },

  "mandatorySteps": {
    "afterTask": [],
    "beforeCommit": [],
    "onSessionEnd": ["updateRequestLog", "updateAppMap"]
  },

  "autoLog": true,
  "autoUpdateAppMap": true,

  "qualityGates": {
    "feature": {
      "require": ["tests", "appMapUpdate", "requestLogEntry"],
      "optional": ["review", "docs"]
    },
    "bugfix": {
      "require": ["tests", "requestLogEntry"],
      "optional": ["review"]
    },
    "refactor": {
      "require": ["tests", "noNewFeatures"],
      "optional": ["review"]
    }
  },

  "strictMode": {
    "verificationChecklist": $STRICT_VERIFICATION,
    "correctionReportsOnFail": $STRICT_CORRECTIONS,
    "featureReportsOnComplete": $STRICT_REPORTS
  },

  "requireApproval": [],

  "componentRules": {
    "preferVariants": true,
    "requireAppMapEntry": true,
    "requireDetailDoc": false,
    "autoGenerateStorybook": $ENABLE_STORYBOOK,
    "storybookPath": "src/stories"
  },

  "testing": {
    "runAfterTask": false,
    "runBeforeCommit": $ENABLE_HOOKS
  },

  "browserTesting": {
    "enabled": false,
    "runOnTaskComplete": false,
    "runForUITasks": true,
    "autoRun": false,
    "timeout": 30000,
    "screenshotOnFailure": true,
    "baseUrl": "http://localhost:3000"
  },

  "hooks": {
    "preCommit": $ENABLE_HOOKS
  },

  "skills": {
    "installed": []
  },

  "componentIndex": {
    "autoScan": true,
    "scanOn": ["sessionStart"],
    "directories": ["src/components", "src/hooks", "src/services", "src/pages", "src/modules", "app"],
    "ignore": ["*.test.*", "*.spec.*", "*.stories.*", "index.ts", "index.js", "__tests__", "__mocks__"]
  },

  "traces": {
    "saveTo": ".workflow/traces",
    "generateDiagrams": true
  },

  "validation": {
    "afterFileEdit": {
      "enabled": false,
      "commands": {
        "*.ts": ["npx tsc --noEmit"],
        "*.tsx": ["npx tsc --noEmit", "npx eslint {file} --fix"],
        "*.js": ["npx eslint {file} --fix"],
        "*.jsx": ["npx eslint {file} --fix"]
      },
      "fixErrorsBeforeContinuing": true
    },
    "afterTaskComplete": {
      "enabled": true,
      "commands": ["npm run lint", "npm run typecheck"]
    },
    "beforeCommit": {
      "enabled": true,
      "commands": ["npm run lint", "npm run typecheck", "npm run test"]
    }
  },

  "agents": {
    "enabled": ["orchestrator", "story-writer", "developer", "reviewer", "tester"],
    "optional": ["accessibility", "security", "performance", "docs", "design-system", "onboarding"]
  },

  "parallel": {
    "enabled": false,
    "maxConcurrent": 3,
    "autoApprove": false,
    "requireWorktree": true,
    "showProgress": true
  },

  "skillLearning": {
    "enabled": true,
    "triggerOn": ["preCommit", "sessionEnd", "taskComplete"],
    "minChangesForTrigger": 1
  },

  "figmaAnalyzer": {
    "enabled": false,
    "thresholds": {
      "exactMatch": 95,
      "strongMatch": 80,
      "variantCandidate": 60
    },
    "componentDirs": ["src/components", "components"],
    "mcpServer": {
      "port": 3847,
      "autoStart": false
    }
  },

  "worktree": {
    "enabled": false,
    "autoCleanupHours": 24,
    "keepOnFailure": false,
    "squashOnMerge": true
  },

  "hybrid": {
    "enabled": false,
    "provider": null,
    "providerEndpoint": null,
    "model": null,
    "settings": {
      "temperature": 0.7,
      "maxTokens": 4096,
      "maxRetries": 2,
      "timeout": 120000,
      "autoExecute": false
    }
  },

  "multiApproach": {
    "enabled": true,
    "triggers": {
      "patterns": ["complex", "multiple ways", "tricky", "optimization"],
      "manualOnly": false
    },
    "validation": {
      "runTests": true,
      "checkTypes": true,
      "requireAllPass": false
    }
  },

  "autoContext": {
    "enabled": true,
    "maxFiles": 10,
    "searchDepth": 3,
    "includeTests": false,
    "showLoadedFiles": true
  },

  "metrics": {
    "enabled": true,
    "trackCommands": true,
    "retentionDays": 30,
    "problemThreshold": 0.3
  },

  "security": {
    "scanOnCommit": false,
    "blockSecrets": true,
    "allowedPatterns": []
  },

  "modelAdapters": {
    "enabled": true,
    "trackResults": true,
    "learnFromErrors": true
  },

  "codebaseInsights": {
    "enabled": true,
    "regenerateOnMajorChanges": true,
    "includeArchitecture": true,
    "includeConventions": true,
    "includeStatistics": true
  },

  "lsp": {
    "enabled": true,
    "useForNavigation": true,
    "useForCompletion": true
  },

  "contextMonitor": {
    "enabled": true,
    "warnAt": 0.7,
    "criticalAt": 0.85,
    "checkOnSessionStart": true,
    "checkAfterTask": true
  },

  "requestLog": {
    "autoArchive": true,
    "maxRecentEntries": 50,
    "keepRecent": 30,
    "createSummary": true
  },

  "sessionState": {
    "enabled": true,
    "autoRestore": true,
    "maxGapHours": 24,
    "trackFiles": true,
    "trackDecisions": true
  },

  "team": {
    "enabled": false,
    "teamId": null,
    "userId": null,
    "setupId": null,
    "backendUrl": null,
    "syncInterval": 300000,
    "autoSync": true
  },

  "memory": {
    "enabled": true,
    "localDb": ".workflow/memory/local.db",
    "embeddingModel": "Xenova/all-MiniLM-L6-v2",
    "maxLocalFacts": 1000
  },

  "knowledgeRouting": {
    "autoDetect": true,
    "confirmWithUser": true,
    "defaultScope": "local"
  },

  "prd": {
    "enabled": false,
    "maxContextTokens": 2000,
    "chunkSize": 500
  },

  "automaticMemory": {
    "enabled": true,
    "entropyThreshold": 0.7,
    "compactOnSessionEnd": true,
    "relevanceDecay": {
      "enabled": true,
      "decayRate": 0.033,
      "neverAccessedPenalty": 0.1
    },
    "demotion": {
      "relevanceThreshold": 0.3,
      "coldRetentionDays": 90
    },
    "selfTuning": {
      "enabled": false,
      "adjustOnOverflow": true,
      "adjustOnFailures": true
    }
  },

  "automaticPromotion": {
    "enabled": true,
    "threshold": 3,
    "minRelevance": 0.8,
    "destinations": ["decisions.md"],
    "requireApproval": true,
    "autoApplyTeamApproved": true
  }
}
EOF

    echo -e "${GREEN}‚úì${NC} Configuration generated"
}

# Generate state files
generate_state_files() {
    echo -e "${CYAN}Creating state files...${NC}"
    
    # Copy from templates if they exist (for fresh installs)
    local TEMPLATE_DIR="$SCRIPT_DIR/../.workflow/state"
    local template_files=("ready.json" "request-log.md" "progress.md" "component-index.json" "app-map.md" "decisions.md" "feedback-patterns.md")
    
    for tfile in "${template_files[@]}"; do
        if [ -f "$TEMPLATE_DIR/${tfile}.template" ]; then
            if [ ! -f "$WORKFLOW_DIR/state/${tfile}" ]; then
                cp "$TEMPLATE_DIR/${tfile}.template" "$WORKFLOW_DIR/state/${tfile}"
                echo -e "  ${GREEN}‚úì${NC} Created ${tfile} from template"
            fi
        fi
    done
    
    # Generate files that don't have templates or weren't copied
    
    # ready.json with new fields (only if not created from template)
    if [ ! -f "$WORKFLOW_DIR/state/ready.json" ]; then
    cat > "$WORKFLOW_DIR/state/ready.json" << EOF
{
  "lastUpdated": "$(date -Iseconds)",
  "ready": [],
  "inProgress": [],
  "blocked": [],
  "recentlyCompleted": []
}
EOF
    fi
    
    # request-log.md (only if not created from template)
    if [ ! -f "$WORKFLOW_DIR/state/request-log.md" ]; then
    cat > "$WORKFLOW_DIR/state/request-log.md" << EOF
# Request Log

All changes, fixes, and additions are logged here.

---

EOF
    fi
    
    # app-map.md (only if not created from template)
    if [ ! -f "$WORKFLOW_DIR/state/app-map.md" ]; then
    cat > "$WORKFLOW_DIR/state/app-map.md" << EOF
# App Map - Component Registry

## Screens

| Screen | Route | Description |
|--------|-------|-------------|
| - | - | - |

## Modals

| Modal | Trigger | Description |
|-------|---------|-------------|
| - | - | - |

## Components

| Component | Variants | Path |
|-----------|----------|------|
| - | - | - |

EOF
    fi
    
    # decisions.md
    cat > "$WORKFLOW_DIR/state/decisions.md" << EOF
# Project Decisions

Coding patterns, architectural decisions, and conventions.

## Conventions

- 

## Patterns

- 

## Tech Stack

- 

EOF
    
    # progress.md (only if not created from template)
    if [ ! -f "$WORKFLOW_DIR/state/progress.md" ]; then
    cat > "$WORKFLOW_DIR/state/progress.md" << EOF
# Progress - $PROJECT_NAME

## Current Status

| Field | Value |
|-------|-------|
| **Started** | $(date +%Y-%m-%d) |
| **Last Updated** | $(date +%Y-%m-%d) |
| **Total Tasks** | 0 |
| **Completed** | 0 |

---

## Session Log

### Session 1 - $(date +%Y-%m-%d)

**Focus:** Project initialization

**Activities:**
- Initialized Wogi Flow workflow
- Created project structure

**Next Session:**
- Define initial tasks
- Set up development environment

EOF
    fi
    
    # feedback-patterns.md
    cat > "$WORKFLOW_DIR/state/feedback-patterns.md" << EOF
# Feedback Patterns

Patterns learned from corrections and feedback.

## Patterns

| Pattern | Source | Applied |
|---------|--------|---------|
| - | - | - |

EOF
    
    echo -e "${GREEN}‚úì${NC} State files created"
}

# Generate phase files if phase-based
generate_phase_files() {
    if [ "$PLANNING_STYLE" = "phase-based" ]; then
        echo -e "${CYAN}Creating phase planning files...${NC}"
        
        cat > "$WORKFLOW_DIR/specs/ROADMAP.md" << EOF
# $PROJECT_NAME - Project Roadmap

## Phase Overview

| Phase | Name | Features | Status |
|-------|------|----------|--------|
| 0 | Project Setup | - | Not Started |
| 1 | Core Infrastructure | - | Not Started |
| 2 | Core Features | - | Not Started |
| 3 | Business Logic | - | Not Started |
| 4 | Testing & Docs | - | Not Started |

---

## Phase 0: Project Setup

**Goal:** Working project with basic configuration

### Features
| ID | Name | Priority | Dependencies |
|----|------|----------|--------------|
| - | - | - | - |

### Acceptance Criteria
- [ ] Project builds successfully
- [ ] Basic structure in place

---

## Phase 1: Core Infrastructure

**Goal:** Foundation ready for features

### Features
| ID | Name | Priority | Dependencies |
|----|------|----------|--------------|
| - | - | - | - |

---

*Add more phases as needed*

EOF
        
        echo -e "${GREEN}‚úì${NC} Phase planning files created"
    fi
}

# Install skills
install_skills() {
    if [ "$SKILLS" != "none" ] && [ -n "$SKILLS" ]; then
        echo -e "${CYAN}Installing skills...${NC}"
        
        IFS=',' read -ra SKILL_ARRAY <<< "$SKILLS"
        for skill in "${SKILL_ARRAY[@]}"; do
            skill=$(echo "$skill" | xargs)  # trim whitespace
            
            if [ -d "$SCRIPT_DIR/../skills/$skill" ]; then
                cp -r "$SCRIPT_DIR/../skills/$skill" "skills/"
                echo -e "${GREEN}‚úì${NC} Installed skill: $skill"
                
                # Update config with installed skill
                python3 << EOF
import json
with open('$WORKFLOW_DIR/config.json', 'r') as f:
    config = json.load(f)
if '$skill' not in config['skills']['installed']:
    config['skills']['installed'].append('$skill')
with open('$WORKFLOW_DIR/config.json', 'w') as f:
    json.dump(config, f, indent=2)
EOF
            else
                echo -e "${YELLOW}‚ö†${NC} Skill not found: $skill (will be available in skills repository)"
            fi
        done
    fi
}

# Copy core files
copy_core_files() {
    echo -e "${CYAN}Copying core files...${NC}"

    # Copy CLAUDE.md
    if [ -f "$SCRIPT_DIR/../CLAUDE.md" ]; then
        cp "$SCRIPT_DIR/../CLAUDE.md" "./CLAUDE.md"
        # Update project name in CLAUDE.md
        sed -i "s/projectName\": \"\"/projectName\": \"$PROJECT_NAME\"/" "./CLAUDE.md" 2>/dev/null || true
    fi

    # Copy .claude/docs directory
    if [ -d "$SCRIPT_DIR/../.claude/docs" ]; then
        mkdir -p ".claude/docs"
        cp -r "$SCRIPT_DIR/../.claude/docs/"* ".claude/docs/" 2>/dev/null || true
        echo -e "${GREEN}‚úì${NC} Documentation files copied"
    fi

    # Copy agents based on structure
    if [ "$AGENT_STRUCTURE" = "unified" ]; then
        if [ -d "$SCRIPT_DIR/../agents" ]; then
            cp -r "$SCRIPT_DIR/../agents/"* ".claude/agents/" 2>/dev/null || true
        fi
    else
        # Split structure - copy from split agents if available
        if [ -d "$SCRIPT_DIR/../agents-split" ]; then
            cp -r "$SCRIPT_DIR/../agents-split/"* ".claude/agents/" 2>/dev/null || true
        fi
    fi
    
    # Copy commands
    if [ -d "$SCRIPT_DIR/../.claude/commands" ]; then
        cp -r "$SCRIPT_DIR/../.claude/commands/"* ".claude/commands/" 2>/dev/null || true
    fi
    
    # Copy templates
    if [ -d "$SCRIPT_DIR/../templates" ]; then
        mkdir -p ".workflow/templates"
        cp -r "$SCRIPT_DIR/../templates/"* ".workflow/templates/" 2>/dev/null || true
    fi
    
    echo -e "${GREEN}‚úì${NC} Core files copied"
}

# Setup hooks if enabled
setup_hooks() {
    if [ "$ENABLE_HOOKS" = true ]; then
        echo -e "${CYAN}Setting up git hooks...${NC}"
        "$SCRIPT_DIR/flow-setup-hooks" install 2>/dev/null || echo -e "${YELLOW}‚ö†${NC} Could not install hooks (not a git repo?)"
    fi
}

# Migrate old .claude/skills to skills/
migrate_old_skills() {
    local old_skills_dir=".claude/skills"
    local new_skills_dir="skills"

    if [ -d "$old_skills_dir" ]; then
        echo -e "${CYAN}Migrating skills from .claude/skills/ to skills/...${NC}"

        # Create skills directory if needed
        mkdir -p "$new_skills_dir"

        # Move each skill directory
        for skill_dir in "$old_skills_dir"/*/; do
            if [ -d "$skill_dir" ]; then
                skill_name=$(basename "$skill_dir")
                if [ -d "$new_skills_dir/$skill_name" ]; then
                    # Already exists in new location, remove old
                    rm -rf "$skill_dir"
                    echo -e "  ${YELLOW}-${NC} $skill_name (already exists)"
                else
                    # Move to new location
                    mv "$skill_dir" "$new_skills_dir/"
                    echo -e "  ${GREEN}‚úì${NC} Migrated: $skill_name"
                fi
            fi
        done

        # Handle skills-index.json
        if [ -f "$old_skills_dir/skills-index.json" ]; then
            if [ ! -f "$new_skills_dir/skills-index.json" ]; then
                mv "$old_skills_dir/skills-index.json" "$new_skills_dir/"
                echo -e "  ${GREEN}‚úì${NC} Migrated: skills-index.json"
            else
                rm "$old_skills_dir/skills-index.json"
            fi
        fi

        # Remove empty .claude/skills directory
        rmdir "$old_skills_dir" 2>/dev/null && echo -e "  ${GREEN}‚úì${NC} Cleaned up .claude/skills/"
    fi
}

# Install LSP dependencies for auto-context enrichment
install_lsp_dependencies() {
    # Only install if this is a Node.js project
    if [ ! -f "package.json" ]; then
        return 0
    fi

    echo -e "${CYAN}Installing LSP dependencies for enhanced auto-context...${NC}"

    # Check if typescript-language-server is already installed
    if command -v typescript-language-server &> /dev/null; then
        echo -e "  ${GREEN}‚úì${NC} typescript-language-server already installed (global)"
        return 0
    fi

    # Check if it's in local node_modules
    if [ -f "node_modules/.bin/typescript-language-server" ]; then
        echo -e "  ${GREEN}‚úì${NC} typescript-language-server already installed (local)"
        return 0
    fi

    # Ask user before installing
    echo ""
    echo "  LSP enrichment provides:"
    echo "    ‚Ä¢ Type information for discovered files"
    echo "    ‚Ä¢ Error/warning indicators"
    echo "    ‚Ä¢ Exported function/class names"
    echo ""
    read -p "  Install typescript-language-server as dev dependency? (Y/n): " install_lsp

    if [[ "$install_lsp" =~ ^[Nn]$ ]]; then
        echo -e "  ${YELLOW}‚óã${NC} Skipped LSP installation (can install later with: npm i -D typescript-language-server typescript)"
        return 0
    fi

    # Install as dev dependency
    if npm install --save-dev typescript-language-server typescript 2>/dev/null; then
        echo -e "  ${GREEN}‚úì${NC} typescript-language-server installed"
    else
        echo -e "  ${YELLOW}‚ö†${NC} Could not install typescript-language-server"
        echo "     You can install it manually: npm i -D typescript-language-server typescript"
    fi
}

# Print completion message
print_completion() {
    echo ""
    echo -e "${GREEN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${GREEN}‚ïë                                                               ‚ïë${NC}"
    echo -e "${GREEN}‚ïë           ‚úÖ Wogi Flow installed successfully!               ‚ïë${NC}"
    echo -e "${GREEN}‚ïë                                                               ‚ïë${NC}"
    echo -e "${GREEN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo -e "${YELLOW}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${YELLOW}‚ïë  ‚ö†Ô∏è  STRICT MODE ENABLED (default)                            ‚ïë${NC}"
    echo -e "${YELLOW}‚ïë                                                               ‚ïë${NC}"
    echo -e "${YELLOW}‚ïë  Claude will now STOP before any implementation to:          ‚ïë${NC}"
    echo -e "${YELLOW}‚ïë  ‚Ä¢ Create a task (for all work)                               ‚ïë${NC}"
    echo -e "${YELLOW}‚ïë  ‚Ä¢ Create a story (for medium/large tasks)                    ‚ïë${NC}"
    echo -e "${YELLOW}‚ïë  ‚Ä¢ Get your approval before proceeding                        ‚ïë${NC}"
    echo -e "${YELLOW}‚ïë                                                               ‚ïë${NC}"
    echo -e "${YELLOW}‚ïë  To disable: edit .workflow/config.json ‚Üí enforcement.strictMode${NC}"
    echo -e "${YELLOW}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo -e "${BOLD}Next steps:${NC}"
    echo ""
    echo "  1. Review configuration:"
    echo "     ${CYAN}cat .workflow/config.json${NC}"
    echo ""
    echo "  2. Create your first task:"
    echo "     ${CYAN}/wogi-story \"Your first feature\"${NC}"
    echo ""
    echo "  3. Check workflow health:"
    echo "     ${CYAN}/wogi-health${NC}"
    echo ""
    echo "  4. See all commands:"
    echo "     ${CYAN}/wogi-help${NC}"
    echo ""
    
    if [ "$SKILLS" != "none" ] && [ -n "$SKILLS" ]; then
        echo -e "${BOLD}Installed skills:${NC}"
        echo "  Run /wogi-skills to see skill-specific commands"
        echo ""
    fi
    
    echo -e "${YELLOW}Tip:${NC} Add .workflow/ to git to track workflow state with your code."
    echo ""
}

# Main installation flow
main() {
    print_header
    check_existing
    ask_setup_type

    ask_project_name
    ask_project_type
    ask_agent_structure
    ask_correction_mode
    ask_planning_style
    ask_tech_stack
    ask_optional_features

    confirm_settings

    echo -e "${CYAN}Installing Wogi Flow...${NC}"
    echo ""

    create_structure
    generate_config
    generate_state_files
    generate_phase_files
    copy_core_files
    setup_hooks
    migrate_old_skills
    install_lsp_dependencies

    # Run tech stack wizard if selected
    if [ "$RUN_STACK_WIZARD" = true ]; then
        echo ""
        echo -e "${CYAN}Starting Tech Stack Wizard...${NC}"
        echo ""
        if [ -f "$SCRIPT_DIR/flow-stack-wizard.js" ]; then
            # Pass detected framework if existing project
            if [ "$IS_EXISTING_PROJECT" = true ] && [ -n "$DETECTED_FRAMEWORK" ]; then
                DETECTED_FRAMEWORK="$DETECTED_FRAMEWORK" node "$SCRIPT_DIR/flow-stack-wizard.js"
            else
                node "$SCRIPT_DIR/flow-stack-wizard.js"
            fi
        else
            echo -e "${YELLOW}Tech stack wizard not found. Run /wogi-setup-stack in Claude Code.${NC}"
        fi
    fi

    print_completion
}

# Run with --quick for non-interactive install with defaults
if [ "${1:-}" = "--quick" ]; then
    PROJECT_NAME="${2:-$(basename "$(pwd)")}"
    create_structure
    generate_config
    generate_state_files
    copy_core_files
    migrate_old_skills

    # Auto-install LSP dependencies for Node.js projects (non-interactive)
    if [ -f "package.json" ]; then
        if ! command -v typescript-language-server &> /dev/null && [ ! -f "node_modules/.bin/typescript-language-server" ]; then
            echo -e "${CYAN}Installing LSP dependencies...${NC}"
            npm install --save-dev typescript-language-server typescript 2>/dev/null && \
                echo -e "  ${GREEN}‚úì${NC} typescript-language-server installed" || \
                echo -e "  ${YELLOW}‚óã${NC} LSP install skipped (run: npm i -D typescript-language-server typescript)"
        fi
    fi

    echo -e "${GREEN}‚úì Quick install complete${NC}"
    echo ""
    echo -e "${YELLOW}‚ö†Ô∏è  STRICT MODE ENABLED (default)${NC}"
    echo -e "   Claude will STOP before implementation to create tasks/stories."
    echo -e "   To disable: edit .workflow/config.json ‚Üí enforcement.strictMode"
    echo ""
    echo -e "${CYAN}üí° Tip:${NC} Run /wogi-setup-stack to configure your tech stack."
    echo -e "   This will generate coding patterns for your frameworks."
    echo ""
    exit 0
fi

# Run with --help
if [ "${1:-}" = "--help" ] || [ "${1:-}" = "-h" ]; then
    echo "Wogi Flow Installer"
    echo ""
    echo "Usage:"
    echo "  flow install           Interactive installation"
    echo "  flow install --quick   Quick install with defaults"
    echo "  flow install --help    Show this help"
    exit 0
fi

main
